/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-vosk.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : vosk
 #	author : miyako
 #	2025/06/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-vosk.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- vosk
            
			case 1 :
				vosk(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}

static FILE *ufopen(const char* filename, const char* mode) {
#ifdef _WIN32
    wchar_t    buf[_MAX_PATH];
    wchar_t    _wfmode[99];    //should be enough
    if (MultiByteToWideChar(CP_UTF8, 0, mode, -1, (LPWSTR)_wfmode, 99))
    {
        if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, (LPWSTR)buf, _MAX_PATH))
        {
            return _wfopen((const wchar_t*)buf, (const wchar_t*)_wfmode);
        }
    }
    return  fopen(filename, mode);
#else
    return std::fopen(filename, mode);
#endif
}

static void getFolderPath(PA_ObjectRef options, const wchar_t *key, std::string& path) {
  
    if(options) {
        PA_ObjectRef folder = ob_get_o(options, key);
        if(folder) {
            if(!folder_object_to_path(folder, path)) {
                CUTF8String stringValue;
                if(!ob_get_s(options, key, &stringValue)) {
                    path = (const char *)stringValue.c_str();
                }
            }
        }
    }
}

void vosk(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    PA_Variable success = PA_CreateVariable(eVK_Boolean);
    PA_SetBooleanVariable(&success, 0);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    if(options != NULL) {
        
        std::string modelFolderPath;
        getFolderPath(options, L"model", modelFolderPath);
        
        std::string speakerFolderPath;
        getFolderPath(options, L"speaker", speakerFolderPath);
        
        float sample_rate = 16000.0;
        if(ob_is_defined(options, L"rate")) {
            sample_rate = ob_get_n(options, L"rate");
        }
        
        VoskModel *model = NULL;
        VoskSpkModel *spk_model = NULL;
        
        if(modelFolderPath.length() != 0) {
            model = vosk_model_new(modelFolderPath.c_str());
        }
        if(speakerFolderPath.length() != 0) {
            spk_model = vosk_spk_model_new(speakerFolderPath.c_str());
        }

        if(model) {
            VoskRecognizer *recognizer = NULL;
            
            if(spk_model) {
                recognizer = vosk_recognizer_new_spk(model, sample_rate, spk_model);
            }else{
                recognizer = vosk_recognizer_new(model, sample_rate);
            }
            
            std::string speech;

            if(recognizer) {
                std::string wav;
                std::vector<char>buf(0x2000);
                Json::Value root;
                std::string errors;
                Json::CharReaderBuilder builder;
                Json::CharReader *reader = builder.newCharReader();
                size_t nread;
                auto startTime = std::chrono::high_resolution_clock::now();//time(0);
                if(file_object_to_path(PA_GetObjectParameter(params, 1), wav)) {
                    FILE *wavin = ufopen(wav.c_str(), "rb");
                    if(wavin) {
                        fseek(wavin, 44, SEEK_SET);
                        while (!feof(wavin)) {
                            nread = fread(&buf[0], 1, sizeof(buf), wavin);
                            int accept = vosk_recognizer_accept_waveform(recognizer, &buf[0], (int)nread);
                            switch (accept) {
                                case 0:
                                {//partial
                                    /*
                                    std::string json = vosk_recognizer_partial_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value partial = root["partial"];
                                        if(partial.isString()) {
                                            std::string t = partial.asString();
                                            if(t.length() != 0) {
                                                printf("vosk_recognizer_partial_result: %s\n", t.c_str());
                                            }
                                        }
                                    }
                                     */
                                }
                                    break;
                                case 1:
                                {//silence
                                    std::string json = vosk_recognizer_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value text = root["text"];
                                        if(text.isString()) {
                                            std::string t = text.asString();
                                            if(t.length() != 0) {
                                                if(speech.length() != 0) {
                                                    speech += " ";
                                                }
//                                                printf("vosk_recognizer_result: %s\n", t.c_str());
                                                speech += text.asString();
                                            }
                                        }
                                    }
                                }
                                    break;
                                default:
                                    //exception
                                    break;
                            }
                            auto now = std::chrono::high_resolution_clock::now();//time(0);
                            auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                            if(elapsedTime > 100)
                            {
                                startTime = now;
                                PA_YieldAbsolute();
                            }
                        }//while
                        std::string json = vosk_recognizer_final_result(recognizer);
                        bool parse = reader->parse((const char *)json.c_str(),
                                                   (const char *)json.c_str() + json.size(),
                                                   &root,
                                                   &errors);
                        if(parse) {
                            Json::Value text = root["text"];
                            if(text.isString()) {
                                std::string t = text.asString();
                                if(t.length() != 0) {
                                    if(speech.length() != 0) {
                                        speech += " ";
                                    }
//                                    printf("vosk_recognizer_final_result: %s\n", t.c_str());
                                    speech += text.asString();
                                }
                            }
                        }
                        ob_set_s(returnValue, L"text", speech.c_str());
                        PA_SetBooleanVariable(&success, 1);
                        fclose(wavin);
                    }
                    delete reader;
                }
                vosk_recognizer_free(recognizer);
            }
            if(spk_model){
                vosk_spk_model_free(spk_model);
                spk_model = NULL;
            }
            vosk_model_free(model);
        }
    }
    
    set_object_property(returnValue, "success", success);
    PA_ReturnObject(params, returnValue);
}

