/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-vosk.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : vosk
 #	author : miyako
 #	2025/06/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-vosk.h"

#pragma mark -

std::mutex mutexVosk;
VoskModel *model = NULL;
VoskSpkModel *spk_model = NULL;
VoskRecognizer *recognizer = NULL;
std::string modelFolderPath;
std::string speakerFolderPath;
float sample_rate = 16000.0;
bool isRunning = false;

static void vosk_get_options(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_s(returnValue, L"model", modelFolderPath.c_str());
    ob_set_s(returnValue, L"speaker", speakerFolderPath.c_str());
    ob_set_n(returnValue, L"rate", sample_rate);
    
    PA_ReturnObject(params, returnValue);
}

static void vosk_set_options(PA_PluginParameters params) {
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexVosk);
        
        PA_ObjectRef options = PA_GetObjectParameter(params, 1);
        if(options != NULL) {
            getFolderPath(options, L"model", modelFolderPath);
            getFolderPath(options, L"speaker", speakerFolderPath);
            if(ob_is_defined(options, L"rate")) {
                sample_rate = ob_get_n(options, L"rate");
            }
        }
            
        if(speakerFolderPath.length() != 0) {
            if(spk_model) {
                vosk_spk_model_free(spk_model);
            }
            spk_model = vosk_spk_model_new(speakerFolderPath.c_str());
        }
        
        if(modelFolderPath.length() != 0) {
            if(model) {
                vosk_model_free(model);
            }
            model = vosk_model_new(modelFolderPath.c_str());
        }
        
        if(model) {
            if(recognizer) {
                vosk_recognizer_free(recognizer);
            }
            if(spk_model) {
                recognizer = vosk_recognizer_new_spk(model, sample_rate, spk_model);
            }else{
                recognizer = vosk_recognizer_new(model, sample_rate);
            }
        }
    }
}

static void OnExit()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexVosk);
        
        if(recognizer) {
            vosk_recognizer_free(recognizer);
            recognizer = NULL;
        }

        if(spk_model){
            vosk_spk_model_free(spk_model);
            spk_model = NULL;
        }
        
        if(model){
            vosk_model_free(model);
            model = NULL;
        }
        isRunning = false;
    }
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
			// --- vosk
            
			case 1 :
				vosk(params);
				break;
            case 2 :
                vosk_set_options(params);
                break;
            case 3 :
                vosk_get_options(params);
                break;

                
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}

static FILE *ufopen(const char* filename, const char* mode) {
#ifdef _WIN32
    wchar_t    buf[_MAX_PATH];
    wchar_t    _wfmode[99];    //should be enough
    if (MultiByteToWideChar(CP_UTF8, 0, mode, -1, (LPWSTR)_wfmode, 99))
    {
        if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, (LPWSTR)buf, _MAX_PATH))
        {
            return _wfopen((const wchar_t*)buf, (const wchar_t*)_wfmode);
        }
    }
    return  fopen(filename, mode);
#else
    return std::fopen(filename, mode);
#endif
}

static void getFolderPath(PA_ObjectRef options, const wchar_t *key, std::string& path) {
  
    if(options) {
        PA_ObjectRef folder = ob_get_o(options, key);
        if(folder) {
            if(!folder_object_to_path(folder, path)) {
                CUTF8String stringValue;
                if(!ob_get_s(options, key, &stringValue)) {
                    path = (const char *)stringValue.c_str();
                }
            }
        }
    }
}

#define FRAMES_PER_BUFFER 512

// PortAudio callback: record audio and write to in-memory WAV
static int recordCallback(const void *input, void *output,
                          unsigned long frameCount,
                          const PaStreamCallbackTimeInfo* timeInfo,
                          PaStreamCallbackFlags statusFlags,
                          void *userData) {
    
    UserData *data = (UserData *)userData;
    const short *in = (const short *)input;

    if (input != NULL) {
        //primary buffer for recording
        drwav_write_pcm_frames(&data->wav, frameCount, in);
        //secondary buffer for live processing
        size_t dataLength = frameCount * sizeof(int16_t);
        size_t size = data->pos + dataLength;
        if(size > data->buf.size()) {
            data->buf.resize(size);
        }
        memcpy(&data->buf[data->pos], in, dataLength);
        data->pos += dataLength;
    }

    return paContinue;
}

static void vosk(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    PA_Variable success = PA_CreateVariable(eVK_Boolean);
    PA_SetBooleanVariable(&success, 0);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    
    if(options != NULL) {
        
        unsigned int seconds = 3;
        if(ob_is_defined(options, L"duration")) {
            seconds = ob_get_n(options, L"duration");
        }
        
        std::string outputFilePath;
        PA_ObjectRef outputFile = ob_get_o(options, L"output");
        if(outputFile) {
            file_object_to_path(outputFile, outputFilePath);
        }
        
        PA_long32 method_id = 0;
        bool execute_callback_method = false;
        
        CUTF16String methodName;
        if(ob_get_a(options, L"onData", &methodName)){
            method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
            if (method_id == 0) {
                execute_callback_method = true;
            }
        }
        
        PA_ObjectRef userData = ob_get_o(options, L"userData");
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)methodName.c_str());
        PA_Variable    cbparams[4];
        
        if (method_id)
        {
            cbparams[0] = PA_CreateVariable(eVK_Object);//$1
            cbparams[1] = PA_CreateVariable(eVK_Object);//$2
            if(userData){
                PA_SetObjectVariable(&cbparams[1], userData);
            }
        }
        
        if (execute_callback_method)
        {
            cbparams[0] = PA_CreateVariable(eVK_Unistring);//method
            cbparams[1] = PA_CreateVariable(eVK_Boolean);//result
            cbparams[2] = PA_CreateVariable(eVK_Object);//$1
            cbparams[3] = PA_CreateVariable(eVK_Object);//$2
            if(userData){
                PA_SetObjectVariable(&cbparams[3], userData);
            }
            PA_SetStringVariable(&cbparams[0], &method);
        }

        bool canRun = false;
        if(1)
        {
            std::lock_guard<std::mutex> lock(mutexVosk);
            if(!isRunning) {
                isRunning = true;
                canRun = true;
            }
        }

        if((model) && (canRun)) {
            
            std::string speech;

            if(recognizer) {
                std::string wav;
                std::vector<char>buf(0x2000);
                Json::Value root;
                std::string errors;
                Json::CharReaderBuilder builder;
                Json::CharReader *reader = builder.newCharReader();
                size_t nread;
                auto startTime = std::chrono::high_resolution_clock::now();//time(0);
                if(file_object_to_path(PA_GetObjectParameter(params, 1), wav)) {
                    FILE *wavin = ufopen(wav.c_str(), "rb");
                    if(wavin) {
                        fseek(wavin, 44, SEEK_SET);
                        while (!feof(wavin)) {
                            nread = fread(&buf[0], 1, sizeof(buf), wavin);
                            int accept = vosk_recognizer_accept_waveform(recognizer, &buf[0], (int)nread);
                            switch (accept) {
                                case 0:
                                {//partial
                                    /*
                                    std::string json = vosk_recognizer_partial_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value partial = root["partial"];
                                        if(partial.isString()) {
                                            std::string t = partial.asString();
                                            if(t.length() != 0) {
                                                printf("vosk_recognizer_partial_result: %s\n", t.c_str());
                                            }
                                        }
                                    }
                                     */
                                }
                                    break;
                                case 1:
                                {//silence
                                    std::string json = vosk_recognizer_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value text = root["text"];
                                        if(text.isString()) {
                                            std::string t = text.asString();
                                            if(t.length() != 0) {
                                                if(speech.length() != 0) {
                                                    speech += " ";
                                                }
//                                                printf("vosk_recognizer_result: %s\n", t.c_str());
                                                speech += text.asString();
                                            }
                                        }
                                    }
                                }
                                    break;
                                default:
                                    //exception
                                    break;
                            }
                            auto now = std::chrono::high_resolution_clock::now();//time(0);
                            auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                            if(elapsedTime > 100)
                            {
                                startTime = now;
                                
                                if (execute_callback_method) {
                                    
                                    PA_ObjectRef status = PA_CreateObject();
                                    ob_set_s(status, L"text", speech.c_str());
                                    PA_SetObjectVariable(&cbparams[2], status);
                                    PA_ExecuteCommandByID(1007 /*EXECUTE METHOD*/, cbparams, 4);
                                    PA_Variable statusCode = cbparams[1];
                                    if (PA_GetVariableKind(statusCode) == eVK_Boolean)
                                    {
                                        if (PA_GetBooleanVariable(statusCode))
                                        {
                                            break;
                                        }
                                    }
                                }
                                
                                if (method_id) {
                                    
                                    PA_ObjectRef status = PA_CreateObject();
                                    ob_set_s(status, L"text", speech.c_str());
                                    PA_SetObjectVariable(&cbparams[0], status);
                                    PA_Variable statusCode = PA_ExecuteMethodByID(method_id, cbparams, 2);
                                    if (PA_GetVariableKind(statusCode) == eVK_Boolean)
                                    {
                                        if (PA_GetBooleanVariable(statusCode))
                                        {
                                            break;
                                        }
                                    }
                                }
                                
                                if ((!execute_callback_method) && (!method_id)) {
                                    PA_YieldAbsolute();
                                }
                               
                            }
                        }//while

                        std::string json = vosk_recognizer_final_result(recognizer);
                        bool parse = reader->parse((const char *)json.c_str(),
                                                   (const char *)json.c_str() + json.size(),
                                                   &root,
                                                   &errors);
                        if(parse) {
                            Json::Value text = root["text"];
                            if(text.isString()) {
                                std::string t = text.asString();
                                if(t.length() != 0) {
                                    if(speech.length() != 0) {
                                        speech += " ";
                                    }
//                                    printf("vosk_recognizer_final_result: %s\n", t.c_str());
                                    speech += text.asString();
                                }
                            }
                        }
                        
                        if (execute_callback_method) {
                            
                            PA_ObjectRef status = PA_CreateObject();
                            ob_set_s(status, L"text", speech.c_str());
                            PA_SetObjectVariable(&cbparams[2], status);
                            PA_ExecuteCommandByID(1007 /*EXECUTE METHOD*/, cbparams, 4);
                            
                            PA_ClearVariable(&cbparams[0]);//string (method)
                    //        PA_ClearVariable(&cbparams[1]);//bool (statusCode) don't clear this
                            PA_ClearVariable(&cbparams[2]);//object $1
                            PA_ClearVariable(&cbparams[3]);//object $2
                        }
                        
                        if (method_id) {
                            
                            PA_ObjectRef status = PA_CreateObject();
                            ob_set_s(status, L"text", speech.c_str());
                            PA_SetObjectVariable(&cbparams[0], status);
                            PA_ExecuteMethodByID(method_id, cbparams, 2);
                                                 
                            PA_ClearVariable(&cbparams[0]);//object $1
                            PA_ClearVariable(&cbparams[1]);//object $2
                        }
   
                        ob_set_s(returnValue, L"text", speech.c_str());
                        PA_SetBooleanVariable(&success, 1);
                        fclose(wavin);
                    }
                    delete reader;
                }else{
                    //audio input
                    
                    PaStream *stream = NULL;
                    UserData data;
                    data.buf.resize(0);
                    data.pos = 0;
                    size_t lastRead = 0;
                    size_t nread;
                    
                    drwav_data_format format = {
                        .container = drwav_container_riff,
                        .format = DR_WAVE_FORMAT_PCM,
                        .channels = 1,
                        .sampleRate = static_cast<drwav_uint32>(sample_rate),
                        .bitsPerSample = 16
                    };
                    
                    // Initialize dr_wav to write to memory
                    if (drwav_init_memory_write(&data.wav,
                                                &data.pWavData,
                                                &data.wavDataSize,
                                                &format, NULL)) {
                        if(Pa_Initialize() == paNoError) {
                            if(Pa_OpenDefaultStream(&stream,
                                                    1 /*NUM_CHANNELS*/,
                                                    0 /*INPUT*/,
                                                    paInt16,
                                                    sample_rate,
                                                    FRAMES_PER_BUFFER,
                                                    recordCallback,
                                                    &data) == paNoError){
                                auto startTime = std::chrono::high_resolution_clock::now();//time(0);
                                auto beginTime = startTime;
                                auto duration = 1000 * seconds;
                                int totalElapsedTime;
                                if (Pa_StartStream(stream) == paNoError) {
                                    do {
                                        auto now = std::chrono::high_resolution_clock::now();//time(0);
                                        totalElapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - beginTime).count();
                                        auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                                        
                                        if(elapsedTime > 100)
                                        {
                                            startTime = now;
                                            
                                            if((data.buf.size() > lastRead)){
                                                nread = data.buf.size() - lastRead;
                                                int accept = vosk_recognizer_accept_waveform(recognizer, &data.buf[lastRead], (int)nread);
                                                lastRead += nread;
                                                switch (accept) {
                                                    case 0:
                                                    {//partial
                                                        
                                                        std::string json = vosk_recognizer_partial_result(recognizer);
                                                        bool parse = reader->parse((const char *)json.c_str(),
                                                                                   (const char *)json.c_str() + json.size(),
                                                                                   &root,
                                                                                   &errors);
                                                        if(parse) {
                                                            Json::Value partial = root["partial"];
                                                            if(partial.isString()) {
                                                                std::string t = partial.asString();
                                                                if(t.length() != 0) {
                                                                    printf("vosk_recognizer_partial_result: %s\n", t.c_str());
                                                                }
                                                            }
                                                        }
                                                         
                                                    }
                                                        break;
                                                    case 1:
                                                    {//silence
                                                        std::string json = vosk_recognizer_result(recognizer);
                                                        bool parse = reader->parse((const char *)json.c_str(),
                                                                                   (const char *)json.c_str() + json.size(),
                                                                                   &root,
                                                                                   &errors);
                                                        if(parse) {
                                                            Json::Value text = root["text"];
                                                            if(text.isString()) {
                                                                std::string t = text.asString();
                                                                if(t.length() != 0) {
                                                                    if(speech.length() != 0) {
                                                                        speech += " ";
                                                                    }
    //                                                                printf("vosk_recognizer_result: %s\n", t.c_str());
                                                                    speech += text.asString();
                                                                }
                                                            }
                                                        }
                                                    }
                                                        break;
                                                    default:
                                                        //exception
                                                        break;
                                                }
                                            
                                            
                                            if (execute_callback_method) {
                                                
                                                PA_ObjectRef status = PA_CreateObject();
                                                ob_set_s(status, L"text", speech.c_str());
                                                PA_SetObjectVariable(&cbparams[2], status);
                                                PA_ExecuteCommandByID(1007 /*EXECUTE METHOD*/, cbparams, 4);
                                                PA_Variable statusCode = cbparams[1];
                                                if (PA_GetVariableKind(statusCode) == eVK_Boolean)
                                                {
                                                    if (PA_GetBooleanVariable(statusCode))
                                                    {
                                                        break;
                                                    }
                                                }
                                            }
                                            
                                            if (method_id) {
                                                
                                                PA_ObjectRef status = PA_CreateObject();
                                                ob_set_s(status, L"text", speech.c_str());
                                                PA_SetObjectVariable(&cbparams[0], status);
                                                PA_Variable statusCode = PA_ExecuteMethodByID(method_id, cbparams, 2);
                                                if (PA_GetVariableKind(statusCode) == eVK_Boolean)
                                                {
                                                    if (PA_GetBooleanVariable(statusCode))
                                                    {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        }
                                        PA_YieldAbsolute();
                                    } while (totalElapsedTime < duration);
                                    Pa_StopStream(stream);
                                }//Pa_StartStream
                                Pa_CloseStream(stream);
                            }//Pa_OpenDefaultStream
                            Pa_Terminate();
                        }//Pa_Initialize
                        
                        if((data.buf.size() > lastRead)){
                            nread = data.buf.size() - lastRead;
                            int accept = vosk_recognizer_accept_waveform(recognizer, &data.buf[lastRead], (int)nread);
                            lastRead += nread;
                            switch (accept) {
                                case 0:
                                {//partial
                                    
                                    std::string json = vosk_recognizer_partial_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value partial = root["partial"];
                                        if(partial.isString()) {
                                            std::string t = partial.asString();
                                            if(t.length() != 0) {
                                                printf("vosk_recognizer_partial_result: %s\n", t.c_str());
                                            }
                                        }
                                    }
                                     
                                }
                                    break;
                                case 1:
                                {//silence
                                    std::string json = vosk_recognizer_result(recognizer);
                                    bool parse = reader->parse((const char *)json.c_str(),
                                                               (const char *)json.c_str() + json.size(),
                                                               &root,
                                                               &errors);
                                    if(parse) {
                                        Json::Value text = root["text"];
                                        if(text.isString()) {
                                            std::string t = text.asString();
                                            if(t.length() != 0) {
                                                if(speech.length() != 0) {
                                                    speech += " ";
                                                }
//                                                                printf("vosk_recognizer_result: %s\n", t.c_str());
                                                speech += text.asString();
                                            }
                                        }
                                    }
                                }
                                    break;
                                default:
                                    //exception
                                    break;
                            }
                        
                        }

                        drwav_uninit(&data.wav);
                        
                        if(outputFilePath.length() != 0) {
                            FILE *f = ufopen(outputFilePath.c_str(), "wb");
                            if(f) {
                                fwrite(data.pWavData, 1, data.wavDataSize, f);
                                fclose(f);
                            }
                        }

                        if (data.pWavData) {
                            drwav_free(data.pWavData, NULL);
                        }
                        
                        std::string json = vosk_recognizer_final_result(recognizer);
                        bool parse = reader->parse((const char *)json.c_str(),
                                                   (const char *)json.c_str() + json.size(),
                                                   &root,
                                                   &errors);
                        if(parse) {
                            Json::Value text = root["text"];
                            if(text.isString()) {
                                std::string t = text.asString();
                                if(t.length() != 0) {
                                    if(speech.length() != 0) {
                                        speech += " ";
                                    }
//                                    printf("vosk_recognizer_final_result: %s\n", t.c_str());
                                    speech += text.asString();
                                }
                            }
                        }
                        
                        if (execute_callback_method) {
                            
                            PA_ObjectRef status = PA_CreateObject();
                            ob_set_s(status, L"text", speech.c_str());
                            PA_SetObjectVariable(&cbparams[2], status);
                            PA_ExecuteCommandByID(1007 /*EXECUTE METHOD*/, cbparams, 4);
                            
                            PA_ClearVariable(&cbparams[0]);//string (method)
                    //        PA_ClearVariable(&cbparams[1]);//bool (statusCode) don't clear this
                            PA_ClearVariable(&cbparams[2]);//object $1
                            PA_ClearVariable(&cbparams[3]);//object $2
                        }
                        
                        if (method_id) {
                            
                            PA_ObjectRef status = PA_CreateObject();
                            ob_set_s(status, L"text", speech.c_str());
                            PA_SetObjectVariable(&cbparams[0], status);
                            PA_ExecuteMethodByID(method_id, cbparams, 2);
                                                 
                            PA_ClearVariable(&cbparams[0]);//object $1
                            PA_ClearVariable(&cbparams[1]);//object $2
                        }
                        
                        ob_set_s(returnValue, L"text", speech.c_str());
                        PA_SetBooleanVariable(&success, 1);
                    }
                }
            }
        
            isRunning = false;
        }
    }
    
    set_object_property(returnValue, "success", success);
    PA_ReturnObject(params, returnValue);
}
