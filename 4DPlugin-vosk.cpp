/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-vosk.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : vosk
 #	author : miyako
 #	2025/06/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-vosk.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- vosk
            
			case 1 :
				vosk(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}

static FILE *ufopen(const char* filename, const char* mode) {
#ifdef _WIN32
    wchar_t    buf[_MAX_PATH];
    wchar_t    _wfmode[99];    //should be enough
    if (MultiByteToWideChar(CP_UTF8, 0, mode, -1, (LPWSTR)_wfmode, 99))
    {
        if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, (LPWSTR)buf, _MAX_PATH))
        {
            return _wfopen((const wchar_t*)buf, (const wchar_t*)_wfmode);
        }
    }
    return  fopen(filename, mode);
#else
    return std::fopen(filename, mode);
#endif
}

void vosk(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    PA_Variable success = PA_CreateVariable(eVK_Boolean);
    PA_SetBooleanVariable(&success, 0);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    if(options != NULL) {
        std::string modelFilePath;
        PA_ObjectRef modelFile = ob_get_o(options, L"model");
        if(modelFile) {
            if(!file_object_to_path(modelFile, modelFilePath)) {
                //not a file object
                CUTF8String stringValue;
                if(!ob_get_s(options, L"model", &stringValue)) {
                    modelFilePath = (const char *)stringValue.c_str();
                }
            }
        }
        float sample_rate = 16000.0;
        if(ob_is_defined(options, L"sample_rate")) {
            sample_rate = ob_get_n(options, L"sample_rate");
        }
        
        VoskModel *model = vosk_model_new(modelFilePath.c_str());
        
        if(model) {
            VoskRecognizer *recognizer = vosk_recognizer_new(model, sample_rate);
            if(recognizer) {
                std::string wav;
                std::vector<char>buf(3200);
                size_t nread, final;
                if(file_object_to_path(PA_GetObjectParameter(params, 1), wav)) {
                    FILE *wavin = ufopen(wav.c_str(), "rb");
                    if(wavin) {
                        fseek(wavin, 44, SEEK_SET);
                        while (!feof(wavin)) {
                            nread = fread(&buf[0], 1, sizeof(buf), wavin);
                            final = (size_t)vosk_recognizer_accept_waveform(recognizer, &buf[0], (int)nread);
                            if (final) {
                                printf("%s\n", vosk_recognizer_result(recognizer));
                            } else {
                                printf("%s\n", vosk_recognizer_partial_result(recognizer));
                            }
                        }
                        fclose(wavin);
                    }
                    PA_SetBooleanVariable(&success, 1);
                }
                vosk_recognizer_free(recognizer);
            }
            vosk_model_free(model);
        }
        
    }
    
    set_object_property(returnValue, "success", success);
    PA_ReturnObject(params, returnValue);
}

